C# CURSO UDEMY

----------INSTALAÇÕES----------
Visual Studio Comunitty



----------SOBRE A LINGUAGEM----------
LINGUAGEM PRÉ-COMPILADA
CÓDIGO -> PRÉ COMPILAÇÃO NO CIL (COMMON INTERMEDIATE LANGUAGE) -> COMPILAÇÃO JIT(JUST IN TIME) NA CLR (COOMON LANGUAGE RUNTIME) .NET (MÁQUINA VIRTUAL) -> CÓDIGO DE MÁQUINA



CLASSES FORMAM NAMESPACES (AGRUPAMENTO LÓGICO) 
        |
        V
        ASSEMBLYs (AGRUPAMENTO FÍSICO - DLL ou EXE - BUILD - SUBPROJETO) -> APLICAÇÃO



----------MACETES----------
IDENTAÇÃO AUTOMÁTICA - CTRL + K + D
CW+TAB TAB - ESCREVE Console.WriteLine()
SABER O VALOR MÍNIMO OU MÁXIMO DE UM TIPO DE VARIÁVEL NUMÉRICA
int.MinValue;
int.MaxValue;


-----DEBUGGING-----
CRIAR UM BREAKE POINT - LINHA ONDE SERÁ INICIADO O DEBUG - F9
INICIAR O DEBUG - F5
CHEGANDO AO BREAK POINT - EXECUTAR CADA PASSO - F11 (EXECUTA ATÉ O PASSO A PASSO DE FUNÇÕES EXTERNAS) OU F10
INTERROMPER O DEBUG - SHIFT + F5


JANELA Locals - GUARDA OS VALORES DE TODAS AS VARIÁVEIS DO ESCOPO


----------TIPOS DE VARIÁVEIS----------

TIPOS DE VARIÁVEIS - MAIS COMUNS
C#          .Net FrameworkType    Signed   Bytes(tamanho)    Faixa de valor
____________________________________________________________________________
INTEIRO
_______
int         System.Int32          YES      4                 -2.147.438.648 a 2.147.438.647
long        System.Int64          YES      8                 -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807
sbyte       System.SByte          YES      1                 -128 a 127
byte        System.Byte           NO       1                 0 a 255

FLOAT
______
float       System.Single         YES      4                 1.175494351 E - 38 a 3,402823466 E + 38
double      System.Double         YES      8                 2.2250738585072014 E - 308 a 1,7976931348623158 E + 308
decimal     System.Decimal        YES      12                ±1,0 x 10-28 a ±7,9228 x 1028

STRING
______
char        System.Char           -        2     

BOOL
_____
bool        System.Boolean        -        True or False



STRING
CADEIA DE CARACTÉRES IMUTÁVEL - ASPAS DUPLAS
string nome = "Luciano";


CHAR
REPRESENTA UM ÚNICO CARACTERE - USAR ASPAS SIMPLES
char letra = 'A';

PARA ATRIBUIR VALORES, USAR O CARACTERE DIRETO OU SEU CÓDIGO UNICODE EM https://symbl.cc/pt/unicode-table/
char letra = 'A'
char letra = '\u0041'


OBJECT
TODA VARIÁVEL HERDA DE OBJECT
object nome = "luciano";
object valor = 15;
object numero = 'a';
object x = 40.25f



OVERFLOW DE VARIÁVEL
SEMPRE QUE É ATRIBUÍDO A UMA VARIÁVEL UM VALOR QUE FOGE DO SEU INTERVALO, ELA ASSUME O VALOR OPOSTO. POR EXEMPLO, VARIÁVEIS DO TIPO sbyte ASSUMEM VALORES DE -128 A 127. SE FOR ATRIBUÍDO sbtye x = 128; x vai assumir valor -128.



ESCOPO DE VARIÁVEL
TODA VARIÁVEL PRECISA SER DECLARADA (SEU TIPO) E INICIALIZADA (ATRIBUIR ALGUM VALOR A ELA)
UMA VARIÁVEL DENTRO DE UM ESTRUTURA MENOR NÃO É VISÍVEL FORA DELA
static void Main(...){
        double x = 110;
        if (x>100){
                double desconto = preco * 0.1;
        }
        Console.WriteLine(desconto); //desconto NÃO É VISÍVEL FORA DO IF
}



RECOMENDAÇÕES
long x = 2465795L  (LETRA l AO FINAL DO NÚMERO)
float x = 4.5f (LETRA f AO FINAL DO NÚMERO)
NOMES DE VARIÁVEIS COM CamelCase (lastName)
NOMES DE NAMESPACES, CLASSES, PROPERTIES E MÉTODOS - PascalCase (LastName)
NOMES DE ATRIBUTOS INTERNOS DA CLASSE - _lastName



RESTRIÇÕES DE NOMES DE VARIÁVEL
-NÃO PODE COMEÇAR COM DÍGITO;
-NÃO USAR ACENTO;
-NÃO USAR ESPAÇO EM BRANCO;



----------SAÍDA DE DADOS----------
Console.WriteLine(valor); //MOSTRA NA TELA E QUEBRA A LINHA
Console.Write(valor);//MOSTRA NA TELA SEM QUEBRAR A LINHA - TUDO JUNTO

MOSTRAR UM NÚMERO ESPECÍFICO DE CASAS DECIMAIS DO NÚMERO
double saldo = 50.2589;
Console.WriteLine(saldo.ToString("F2")); //DUAS CASAS DECIMAIS - JÁ ARREDONDADO - 0 A 4 ->0 / 5 A 9 -> 10

TROCAR PONTO POR VÍRGULA
using System.Globalization; //CultureInfo.InvariantCulture
Console.WriteLine(saldo.ToString("F2", CultureInfo.InvariantCulture));//USAR . AO INVÉS DE ,

DIVERSAS VARIÁVEIS NA MESMA SAÍDA
string nome = "Luciano";
double saldo = 50.2589;
int idade = 28;

INTERPOLAÇÃO
Console.WriteLine($"{nome} tem {idade} anos e R${saldo.ToString("f2")} reais na conta!");

PLACEHOLDER
Console.WriteLine("{0} tem {1} anos e R${2:F2} na conta!", nome, idade, saldo);

CONCATENAÇÃO
Console.WriteLine(nome +" tem "+idade+" anos e R$"+saldo.ToString("f2")+" na conta!");



-----ATRIBUIÇÃO-----
= -> RECEBE
a += 2 -> a RECEBE a + 2 (TAMBÉM FUNCIONA COM STRING)
a -= 2 -> ...
a *= 2 -> ...
a /= 2 -> ...
a %= 2 -> a = a%2
a++ -> a=a+1
a-- -> a=a-1

DIFERENÇA ++a E a++
a=10;
b=a++; (B VALE 10 E A VALE 11)

a=10;
b=++a; (B VALE 11 E A VALE 11)

OU SEJA, x=++A - INCREMENTA O a E DEPOIS ATRIBUI SEU VALOR PARA x
         x=a++ - ATIBUI a SEM INCREMENTO A x E DEPOIS INCREMENTA A


-----CONVERSÃO DE TIPOS-----
IMPLÍCITA - ATRIBUIR A UMA VARIÁVEL O VALOR DE OUTRA QUE "CABE" DENTRO DELA
float a = 5.2f;
double b = a; //CONVERSÃO IMPLÍCITA

EXPLÍCITA / CASTING - FORÇAR A CONVERSÃO DO VALOR DE UMA VARIÁVEL PARA OUTRO TIPO, ASSUMINDO O RISCO DA PERDA DE DADOS
double a = 5.2;
float b = (float)a;

CASTING EM OPERAÇÕES
int a = 5;
int b = 2;
double resultado = a / b; //RESULTADO É UM INTEIRO PORQUE O COMPILADOR ENTENDE SOMENTE AS PARTES INTEIRAS DE VARIÁVEIS INTEIRAS PROCESSADAS
double resultado1 = (double) a / b;


-----OPERADORES ARITMÉTICOS-----
+ SOMA
- SUBTRAÇÃO
* MULTIPLICAÇÃO
/ DIVISÃO
% MOD
Math.Pow(x, y) - EXPONENCIAÇÃO -> x elevado a y
Math.Sqrt(x) RAIZ QUADRADA


PRECEDÊNCIA
* / % -> + -
() QUEBRA PRECEDÊNCIA


-----OPERADORES COMPARATIVOS-----
> MAIOR
< MENOR
>= MAIOR OU IGUAL
<= MENOR OU IGUAL
== IGUAL
!= DIFERENTE


---OPERADORES LÓGICOS-----
&& E - 2ª MAIOR PRECEDÊNCIA
|| OU - 3ª MAIOR PRECEDÊNCIA
!  NÃO - MAIOR PRECEDÊNCIA

 

-----ENTRADA DE DADOS-----
Console.ReadLine(); 
LÊ ATÉ A QUEBRA DE LINHA - ENTER
ENTRADA DE DADOS SEMPRE COMO STRING

LER STRINGS DE UM VETOR
string frase = Console.ReadLine();//STRING RECEBE TODAS AS PALAVRAS
string[] vetor = frase.Split(' ');//CADA PALAVRA É SALVA NUMA POSIÇÃO DO VETOR
string p0 = vetor[0];
string p1 = vetor[1];  //CADA PALAVRA É ATRIBUÍDA A UMA NOVA VARIÁVEL
string p2 = vetor[2];

CONVERTER TIPOS NA ENTRADA
int n1 = int.Parse(Consolo.ReadLine());

variavel = tipo_variavel.Parse(Console.ReadLine());

CONVERSÃO DE DECIMAIS COM , OU .
SE A MÁQUINA ESTIVER EM PT-BR, PREENCHER AS VARIÁVEIS COM . DÁ ERRO
double numero = double.Parse(Console.ReadLine()); //ENTRADA 4.55
Console.WriteLine(numero);// SAÍDA 455

PARA QUE FUNCIONE USANDO .
Using System.Globalization
double numero = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture); //ENTRADA 4.55
Console.WriteLine(numero.ToString("f2",CultureInfo.InvariantCulture));// SAÍDA 4.55



-----CONDICIONAL - IF ELSE-----
SIMPLES
if (condicao1){
        comando1
}

COMPOSTA
if(condicao1){
        comando1
}
else{
        comando2
}

ANINHADA/ENCADEADA
if(condicao1){
        comando1
}
else if(condicao2){
        comando2
}
else if(condicao3){
        comando3
}
else{
        comando4
}


-----WHILE-----
while (condicao){
        comando
}



---FOR---
for(inicio; condicao; incremento){
        comando
}


-----FUNÇÕES-----
static <tipo saida> <nome_funcao> (<parametros>){
        <codigo>
        <return variavel>
}

FUNÇÕES AO FINAL, FORA DA MAIN E DENTRO DA CLASS Program - SE ESTIVEREM NO MESMO ARQUIVO .cs

//EXEMPLO
static int Maior_de_tres(int n1, int n2, int n3)
{
    int f_maior = n1;

    if (n2 >= f_maior)
    {
        f_maior = n2;
    }
    else if (n3 >= f_maior)
    {
        f_maior = n3;
    }

    return f_maior;
}


-----ORIENTAÇÃO A OBJETOS-----

CLASSE
TIPO ESTUTURADO QUE PODE CONTER MEMBROS, QUE SÃO:
ATRIBUTOS - DADOS/CAMPOS
MÉTODOS - FUNÇÕES OPERAÇÕES


ALÉM DE:
CONSTRUTORES - 
SOBRECARGA - 
ENCAPSULAMENTO - 
HERANÇA - 
POLIMORFISMO - 

TODA CLASSE EM C# HERDA DA CLASSE OBJECT
NOMES DE ATRIBUTOS - COMEÇANDO MAIÚSCULO
ACESSO A UM ATRIBUTO DA CLASSE COM <objeto da classe>.<nome atributo>

CRIAR CLASSE NO VISUAL STUDIO COMMUNITY
BOTÃO DIREITO NO NAMESPACE ATUAL - ADD - CLASS - NOMEAR (PRIMEIRA LETRA MAIÚSCULA)

EXEMPLO
namespace PrimeiroProjetoOrientadoObjeto
{
    public class Triangulo //PRECISA DO PUBLIC ?
    {
        public double A;
        public double B;
        public double C;

    }
}



NO PROGRAMA PRINCIPAL
INICIALIZAR OBJETOS DO TIPO DA CLASSE E INSTANCIÁ-LOS
namespace PrimerioProjetoOrientadoObjeto
{

    internal class Program
    {
        static void Main(string[] args)
        {
            Triangulo x, y; //INICIALIZAÇÃO DOS OBJETOS TRIÂNGULO

            x = new Triangulo();
            y = new Triangulo();//INSTANCIAÇÃO DOS OBJETOS TRIANGULO

            x.A = 10;
        }
    }
}



-----MÉTODOS-----
public <tipo retorno> <nome método>(<parametros>){
        <codigo>
        return <variavel/valor>
}

NO EXEMPLO DO TRIÂNGULO, UM MÉTODO QUE CALCULE SUA ÁREA

namespace PrimeiroProjetoOrientadoObjeto
{
    class Triangulo //PRECISA DO PUBLIC ?
    {
        public double A;
        public double B;
        public double C;

        public double Area_Triangulo()
        {
            //ÁREA DO TRIÂNGULO CALCULADA PELA FÓRMULA DE HERON
            //FUNÇÃO SEM PARÂMETROS PQ SÓ USA AS PRÓPRIAS INFORMAÇÕES DO OBJETO
            double p = (A + B + C)/2;
            double area_triangulo = Math.Sqrt(p * (p - A) * (p - B) * (p - C));
            return area_triangulo;
         }

    }
}


E NO PROGRAMA PRINCIPAL
//ÁREA DE TRIÂNGULO USANDO CLASSE TRIANGULO E FÓRMULAR DE HERON
Triangulo x, y; //INICIALIZAÇÃO DOS OBJETOS TRIÂNGULO

x = new Triangulo();
y = new Triangulo();//INSTANCIAÇÃO DOS OBJETOS TRIANGULO

Console.WriteLine("Lados primeiro triangulo: ");
x.A = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);
x.B = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);
x.C = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);

Console.WriteLine("Lados segundo triangulo: ");
y.A = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);
y.B = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);
y.C = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);

double area_x = x.Area_Triangulo();
double area_y = y.Area_Triangulo();

Console.WriteLine($"Área do triangulo X: {area_x.ToString("f4", CultureInfo.InvariantCulture)}\n" +
                  $"Área do triângulo Y: {area_y.ToString("f4", CultureInfo.InvariantCulture)}");

if (area_x == area_y)
{
    Console.WriteLine("Áreas iguais!");
}
else if (area_x > area_y)
{
    Console.WriteLine("Maior área: triângulo X");
}
else // areay > areax
{
    Console.WriteLine("Maior área: triângulo Y");
}


-----OBJECTS E TO STRING-----
ToString É UM MÉTODO DA CLASSE GENÉRICA OBJECT QUE PODE SER SOBRESPOSTO NA CLASSE DESEJADA.
SUA UTILIDADE É PERMITIR MOSTRAR OS DADOS DO OBJETO DA MANEIRA DESEJADA, PRECISANDO SOMENTE, NO PROGRAMA PRINCIPAL,
INDICAR O NOME DO OBJETO

NO EXEMPLO DA CLASSE PRODUTO
class Produto
{
    public string Nome;
    public double Preco;
    public int Quantidade;

    public double ValorTotalEmEstoque()
    {
        return Preco* Quantidade;
    }

    public override string ToString()
    {
        return $"{Nome}, $ {Preco.ToString("f2",CultureInfo.InvariantCulture)}, " +
            $"quantidade em estoque: {Quantidade}, " +
            $"valor total em estoque: $ {ValorTotalEmEstoque().
            ToString("f2",CultureInfo.InvariantCulture)}";
    }

}


E NO CÓDIGO PRINCIPAL
Console.WriteLine($"Dados do produto: {produto1}");


-----MEMBROS ESTÁTICOS-----
MEMBROS DE CLASSE, SÃO OS QUE FAZEM SENTINDO INDEPENDENTE DO OBJETO INSTANCIADO.
SÃO CHAMADOS DIRETO PELO NOME DA CLASSE.
ATÉ O MOMENTOS, SÓ FOI VISTO MEMBROS DE INSTÂNCIA (ATRIBUTOS E MÉTODOS PARA O OBJETO INSTANCIADO)

APLICAÇÃO
CLASSES UTILITÁRIAS - Math.Sqrt()
DECLARAÇÃO DE CONSTANTES - 

CLASSES COM MEMBROS EXCLUSIVAMENTE ESTÁTICOS, PODEM SER CLASSES ESTÁTICAS.
CLASSES ESTÁTICAS NÃO PODEM SER INSTANCIADAS.

QUANDO USAR CLASSES/MEMBROS ESTÁTICOS ?
QUANDO A LÓGICA DA CLASSE É A MESMA E A ÚNICA MUDANÇA DEPENDE DE INFORMAÇÕES DE VARIÁVEIS EXTERNAS,
E NÃO DE SEUS ATRIBUTOS.

EXEMPLO
-O CÁLCULO DA ÁREA DO TRIÂNGULO DEPENDE DOS SEUS VALORES DE ATRIBUTOS (LADO A, B e C)
LOGO, NÃO É UMA CLASSE ESTÁTICA.

-O CÁLCULO DA CIRCUNFERÊNCIA DE UM CÍRCULO DEPENDE DE SEU RAIO, MAS SE ESSE RAIO FOR UM
VALOR QUE ESTÁ NO PROGRAMA PRINCIPAL E NÃO UM ATRIBUTO DA CLASSE, ESSA CLASSE PODE SER ESTÁTICA.



*FUNÇÕES ESTÁTICAS SÓ PODEM USAR OUTRAS FUNÇÕES ESTÁTICAS;
static void Main(...){
    ...
    double volume = Volume(raio);
}

static Volume(){
    ...
}

*VARIÁVEIS/MÉTODOS USADAS EM FUNÇÕES ESTÁTICAS PRECISAM SER ESTÁTICAS

static double pi = 3.14;

static void Main(...){
    ...
    double volume = Volume(raio);
}

static Volume(){
    ....pi....
}



-----CONSTRUTORES-----
É A OPERAÇÃO QUE É EXECUTADA NO MOMENTO DE INSTANCIAÇÃO DE UM OBJETO.
PODE SER USADA PARA INICIAR VALORES DE ATRIBUTOS, CRIAR DEPENDÊNCIAS NO OBJETO ()

É POSSÍVEL TER MAIS DE UM CONSTRUTOR PARA A MESMA CLASSE (SOBRECARGA).

SOBRECARGA É UM RECURSO DE CLASSE QUE PERMITE TER MAIS DE UMA OPERAÇÃO COM O MESMO NOME
MAS COM DIFERENTES LISTAS DE PARÂMETROS.

EXEMPLO - CONSTRUTORES DA CLASSE PRODUTO COM SOBRECARGA

//CONSTRUTOR PADRÃO - SÓ PARA HABILITAR SEU USO
public Produto1()
{

}

//CONSTRUTOR COM TODOS OS DADOS
public Produto1(string nome, double preco, int quantidade)
{
    Nome = nome;
    Preco = preco;
    Quantidade = quantidade;
}

//CONTRUTOR COM NOME, PREÇO E QUANTIDADE 0
public Produto1(string nome, double preco)
{
    Nome = nome;
    Preco = preco;
    Quantidade = 0;//SEM ESSSA LINHA, POR PADRÃO, SERIA 0
}


E NO PROGRAMA PRINCIPAL
//USO DE CONSTRUTOR PERSONALIZADO
Produto1 produto1 = new Produto1(nome, preco);
//USO CONSTRUTOR PADRÃO
Produto1 produto2 = new Produto1();



-----SINTAXE ALTERNATIVA PARA CONSTRUTOR-----
AO INVÉS DE DEPENDER DO CONTRUTOR, O C# PERMITE INICIALIZAR OS ATRIBUTOS DIRETO NO PROGRAMA PRINCIPAL,
DESDE QUE NA CLASSE DO OBJETO, NÃO HAJA SOMENTE UM CONSTRUTOR ESPECÍFICO, MAS SIM TAMBÉM UM CONSTRUTOR PADRÃO E
QUE OS ATRIBUTOS NÃO SEJAM PRIVATE

NO PROGRAMA PRINCIPAL
Produto1 produto1 = new Produto1()
{
    Nome = "TV",
    Preco = 1500,
    Quantidade = 10
};



-----THIS-----
É USADA PARA REFERENCIAR O ATRIBUTO DA PRÓPRIA CLASSE, CASO HAJA ALGUMA OUTRA VARIÁVEL LOCAL DE MESMO NOME,
ALÉM DE SERVIR TAMBÉM PARA UTILIZAR AS INFORMAÇÕES DE OUTRO CONTRUTOR EM UM CONSTRUTOR E 
PASSAR O PRÓPRIO OBJETO COMO ARGUMENTO NA CHAMADA DE UM MÉTODO OU CONSTRUTOR.

THIS - DIFERENCIAR ATRIBUTOS DE VARIÁVEIS LOCAIS
public Produto(string Nome, double Preco){
    this.Nome = Nome;
    this.Preco = Preco;
    Quantidade = 0;
}


THIS - REFERENCIAR OUTRO CONSTRUTOR EM UM CONSTRUTOR

//CONSTRUTOR PADRAO
public Produto(){
    Quantidade = 0;
}

//2º CONSTRUTOR, QUE USA AS INFORMAÇÕES DO PADRAO 
public Produto (string nome, double preco) : this() {
    Nome = nome;
    Preco = preco;
}

//3º CONSTRUTOR, QUE USA AS INFORMAÇÕES DO 2º CONSTRUTOR
public Produto(string nome, double preco, int quantidade) : this(nome, preco) {
    Quantidade = quantidade;
}

NESSE CASO, O SEGUNDO CONTRUTOR JÁ VAI TER A INFORMAÇÃO DE QUE Quantidade = 0 PORQUE
ELE USOU AS INFORMAÇÕES DO CONSTRUTOR PADRÃO.
E O TERCEIRO CONSTRUTOR JÁ VAI TER AS INFORMAÇÕES DO SEGUNDO.



THIS - USAR O PRÓPRIO OBJETO DA CLASSE COMO ARGUMENTO NA CHAMADA DE UM DE SEUS MÉTODOS OU CONTRUTORES
class ChessMatch {
    ....
    PlaceNewPiece('e', 1, new King(board, Color.White, this));
    ...
}

NESSE CASO ACIMA, NA CLASSE ChessMatch, o método PlaceNewPiece UTILIZA O PRÓPRIO OBJETO DA CLASSE COMO ARGUMENTO.



-----ENCAPSULAMENTO-----
PRINCÍPIO QUE CONSISTE EM ESCONDER DETALHES DE IMPLEMENTAÇÃO DE UM COMPONENTE, EXPONDO APENAS
OPERAÇÕES SEGURAS E QUE O MANTENHA EM ESTADO CONSISTENTE.
A PRÓPRIA CLASSE DEVE GARANTIR ESSA CONSISTÊNCIA.

TODO ATRIBUTO PRIVATE (SÓ PODE SER ACESSADO PELA PRÓPRIA CLASSE)
E 
GET E SET PARA CADA ATRIBUTO (PERMITE IMPLEMENTAR LÓGICAS PARA GET E SET DOS ATRIBUTOS)
(NÃO É USUAl NO C#)

private string _nome;
private double _preco;
private int _quantidade;

public string GetNome()
{
    return _nome;
}

public void SetNome(string nome)
{
    _nome = nome;
}

UM ATRIBUTO PRIVATE MUDA SEU PADRÃO DE ESCRITA
private string _nome;



-----PROPERTIES NO LUGAR DE GETS E SETS-----
UMA PROPERTIE PODE SER USADA PARA TORNAR MAIS INTUITIVO O USO DOS ATRIBUTOS NO PROGRAMA PRINCIPAL E
MANTER A LÓGICA E SEGURANÇA NA IMPLEMENTAÇÃO DO SET E GET DOS ATRIBUTOS

COM GET E SET
NA CLASSE
public string GetNome()
{
    return _nome;
}

public void SetNome(string nome)
{
    //NOME SÓ É MODIFICADO SE NÃO FOR VAZIO E TIVER MAIS QUE UMA LETRA
    if (nome != null && nome.Length > 1)
    {
        _nome = nome;
    }
}

NO PROGRAMA PRINCIPAL
produto1.SetNome("TVZONA");
string nome = produto1.GetNome();
Console.WriteLine(nome);



COM PROPERTIE APLICADA AO GET E SET DE _nome
NA CLASSE
public string Nome
{
    get { return _nome; }
    set {
        if (value != null && value.Length > 1)//value VAI SER OQ ESTIVER SENDO ATRIBUÍDO AO NOME, NO PROGRAMA PRINCIPAL
        {
            _nome = value;
        }
    }
}

NO PROGRAMA PRINCIPAL
produto1.Nome = "TVZONA";
string nome = produto1.Nome; //USO DO GET PELA PROPERTIE
Console.WriteLine(nome);


-----AUTO PROPERTIES (PROPRIEDADES AUTO IMPLEMENTADAS)-----
SÃO PROPERTIES SIMPLIFICADAS QUE PODEM SER UTILIZADAS PARA ATRIBUTOS QUE NÃO PRECISAM DE NENHUM LÓGICA INTERNA ELABORADA

AUTO PROPERTIE PARA OS ATRIBUTOS PREÇO E QUANTIDADE DA CLASSE PRODUTOS
NA CLASSE
public double Preco { get; private set; }
public int Quantidade { get; private set; }
//private set DETERMINA QUE O MÉTODO set DESSES ATRIBUTOS SÓ É ACESSÍVEL NA CLASSE

SUBSTITUINDO AS PROPERTIES MANUAIS
public double Preco
{
    get { return _preco; }
}

public int Quantidade
{
    get { return _quantidade; }
}

NO PROGRAMA PRINCIPAL
//DA MESMA FORMA QUE ANTERIORMENTE
produto1.Nome = "TVZONA";
string nome = produto1.Nome; //USO DO GET PELA PROPERTIE
Console.WriteLine(nome);




-----MODIFICADORES DE ACESSO-----

PARA MEMBROS DAS CLASSES

                      própria classe   subclasse no assembly   classes do assembly   subclasse fora do assembly   classes fora do assembley
public              |       X                   X                       X                        X                           X

protected internal  |       X                   X                       X                        X                           

internal            |       X                   X                       X                                                    

protected           |       X                   X                                                X                           

private protected   |       X                   X                                                                            

private             |       X                                                                    X                           


*assembly == projeto

PARA CLASSES
CLASSE ACESSÍVEL POR QUALQUER OUTRA - public class
CLASSE ACESSÍVEL SOMENTE NO PROJETO - internal class (padrão)
CLASSE ACESSÍVEL SOMENTE PELA CLASSE MÃE (CLASSE MAIOR QUE TEM A MENOR DENTRO DELA) - private class



-----BOAS PRÁTICAS-----
ORDEM DE IMPLEMENTAÇÃO NA CLASSE
-ATRIBUTOS PRIVADOS
-AUTOPROPERTIES
-CONSTRUTORES
-PROPERTIES MANUAIS
-DEMAIS MÉTODOS











-----RASCUNHOS-----
SABER SE VARIÁVEL ESTÁ VAZIA
STRING
nome == null

NUMÉRICA
valor == 0 (POR PADRÃO, NÚMEROS ASSUMEM VALOR 0)

SABER TAMANHO DA STRING
nome.Legth > 1



-----UML-----

REPRESENTAÇÃO DE CLASSE NA UML

------------------------------------------
                NOME CLASSE
------------------------------------------
             -ATRIBUTO: TIPO;
             -ATRIBUTO: TIPO;
------------------------------------------
    +MÉTODO(<PARAMETROS>): <TIPO RETORNO>
    +MÉTODO(<PARAMETROS>): <TIPO RETORNO>
------------------------------------------














